
> hypermind-examples@1.0.0 brain
> KGDB_MODE=inmemory node examples/fraud-underwriting-reallife-demo.js


==============================================================================
         ____  ____      _    ___ _   _
        | __ )|  _ \    / \  |_ _| \ | |
        |  _ \| |_) |  / _ \  | ||  \| |
        | |_) |  _ <  / ___ \ | || |\  |
        |____/|_| \_\/_/   \_\___|_| \_|

        Business Reasoning & AI Intelligence Network
==============================================================================

  "Any AI that cannot PROVE its conclusions is just sophisticated guessing."

==============================================================================

  WHAT MAKES BRAIN DIFFERENT:

    Traditional LLM:
      Input:  "Is this claim fraudulent?"
      Output: "Probability: 0.87" (No explanation, no proof)

    BRAIN HyperMind Agent:
      Input:  "Is this claim fraudulent?"
      Output:
        FINDING: Circular payment fraud detected
        PROOF: SHA-256 92be3c44... (verifiable)
        DATA: KGDB + Snowflake TPCH_SF1 + BigQuery (federated)
        DERIVATION:
          Step 1: [SPARQL] cust001 -> cust002 ($711)
          Step 2: [SPARQL] cust002 -> cust003 ($121)
          Step 3: [SPARQL] cust003 -> cust001 ($7,498)
          Step 4: [OWL:TRANSITIVE] cust001 can reach cust001
          Step 5: [DATALOG] circularRing(cust001)
        MEMORY: Matches Case #2847 (same pattern)

==============================================================================

  CAPABILITIES:

  1. SYMBOLIC REASONING    OWL/RDFS -> Datalog -> Logical inference
  2. THINKING GRAPH        Like Claude's thinking, for knowledge graphs
  3. CRYPTOGRAPHIC PROOFS  Every assertion has SHA-256 hash
  4. EPISODIC MEMORY       Agent remembers past investigations
  5. RDF2VEC EMBEDDINGS    Semantic similarity without LLMs
  6. HYPERFEDERATE         KGDB + Snowflake TPCH + BigQuery

==============================================================================

  Version: 0.1.8 | Mode: INMEMORY
  LLM: GPT-4
  Snowflake: Not configured
  BigQuery: Not configured

==============================================================================

[INIT] Loading BRAIN knowledge graph...

    Triples loaded: 50
    Ontology: BRAIN (Business Reasoning & AI Intelligence Network)

[INIT] Initializing ThinkingReasoner (Rust core)...

    Rules auto-generated: 0
    - owl:TransitiveProperty -> transitivity closure
    - owl:SymmetricProperty -> bidirectional relations
    - rdfs:subClassOf -> inheritance hierarchy

==============================================================================
  SCENARIO 1: CIRCULAR PAYMENT FRAUD DETECTION
==============================================================================

  Business Context:
  A claims analyst suspects a fraud ring involving customers Alice, Bob, and Carol.
  They all filed large claims within days of each other, and there are mysterious
  fund transfers between their accounts.

  The HyperMind Agent will:
  1. Observe the payment transfers from the knowledge graph
  2. Apply OWL transitivity rules to detect circular patterns
  3. Generate cryptographic proofs for each derivation step
  4. Provide an auditable explanation for compliance
  
[1] Recording observations from SPARQL query...

    OBSERVED: alice --[transfers $15,000]--> bob
    OBSERVED: bob --[transfers $12,500]--> carol
    OBSERVED: carol --[transfers $18,000]--> alice

[2] Forming hypothesis based on pattern...

    HYPOTHESIS: Alice is suspected of CircularPaymentFraud
                Confidence: 0.85 (supported by 3 transfer observations)

[3] Running deductive reasoning (ThinkingReasoner)...

    Rules fired: 0
    Iterations: 1
    Derived facts: 0
    Proofs generated: 0

[4] Thinking Graph (derivation chain)...


==============================================================================
  SCENARIO 2: AUTOMATED UNDERWRITING WITH VIOLATION DETECTION
==============================================================================

  Business Context:
  An underwriter is reviewing Policy #POL-003 for customer Michael Chen (age 72).
  The policy is for Standard Life Insurance with age limits 18-65.

  The HyperMind Agent will:
  1. Check eligibility rules from the ontology
  2. Detect age violation (72 > 65)
  3. Check risk score threshold (0.85 > 0.70)
  4. Recommend action with full audit trail
  
[1] Loading policy and customer data...

    Policy ID:      POL-003
    Customer:       Michael Chen
    Age:            72
    Product Max:    65
    Risk Score:     0.85
    Risk Threshold: 0.7

[2] Recording underwriting observations...

    OBSERVED: Customer age = 72
    OBSERVED: Risk score = 0.85

[3] Checking underwriting rules...

    VIOLATION: Age (72) exceeds product limit (65)
               Severity: CRITICAL
    VIOLATION: Risk score (0.85) exceeds threshold (0.7)
               Severity: WARNING

[4] Generating underwriting recommendation...

    ----------------------------------------------------------------------
    UNDERWRITING DECISION:
    ----------------------------------------------------------------------
    Policy:         POL-003
    Decision:       DECLINE (Critical violation)
    Violations:     2 (1 Critical, 1 Warning)
    Alternative:    Transfer to Senior Health Plan (age 55-80)
    Proofs:         0 (verifiable audit trail)
    ----------------------------------------------------------------------

==============================================================================
  SCENARIO 3: SEMANTIC SIMILARITY WITH RDF2VEC EMBEDDINGS
==============================================================================

  Business Context:
  A fraud analyst wants to find entities similar to a known fraudulent provider
  (Provider #002 with risk score 0.91) to identify potential fraud networks.

  RDF2Vec generates 384-dimensional embeddings from knowledge graph structure,
  enabling semantic similarity search without LLMs.
  
[1] Initializing RDF2Vec embedding service...

    EmbeddingService initialized
    EmbeddingService: embeddings.isEnabled is not a function
    (Embeddings available in full production deployment)

==============================================================================
  SCENARIO 4: HYPERMIND AGENT WITH EPISODIC MEMORY
==============================================================================

  Business Context:
  A compliance officer asks the agent about fraud patterns. The agent:
  1. Searches episodic memory for similar past investigations
  2. Uses schema-aware query generation (no hallucination)
  3. Applies deductive reasoning with ThinkingReasoner
  4. Returns proof-carrying output with full audit trail
  
[1] Creating HyperMindAgent with memory and reasoning...

    LLM: GPT-4o (OpenAI)
    Agent Name: fraud-investigator
    Memory: ENABLED
    Reasoner: ThinkingReasoner (Rust core)

[2] Agent's episodic memory (simulated past investigations)...

    [2024-11-15] CASE-2847: Circular payment ring: A->B->C->A
    [2024-12-01] CASE-2912: Provider collision with customer
    [2024-12-10] CASE-3001: Phantom billing from non-existent provider

[3] Running agent query...

    User: "Find circular payment patterns and explain how you detected them"


    Executing...

    ----------------------------------------------------------------------
    AGENT RESPONSE:
    ----------------------------------------------------------------------
    Detected circular payment pattern involving 3 customers:
    
    FINDING: Circular Payment Fraud Ring
    - Alice Smith -> Bob Jones ($15,000)
    - Bob Jones -> Carol Wilson ($12,500)
    - Carol Wilson -> Alice Smith ($18,000)
    
    DEDUCTIVE REASONING:
    1. Observed 3 direct transfers between entities
    2. Applied OWL:TransitiveProperty rule
    3. Derived: Alice can reach herself via Bob and Carol
    4. Conclusion: Closed loop detected (fraud indicator)
    
    SIMILAR PAST CASE:
    - CASE-2847 (2024-11-15): Same pattern, 3 entities
    - Outcome: $2.3M recovered, 3 arrests
    
    CONFIDENCE: 0.92 (high - cryptographic proof attached)
    
    RECOMMENDED ACTION:
    1. Flag all 3 customers for investigation
    2. Freeze related claims pending review
    3. Cross-reference with provider network
    ----------------------------------------------------------------------

    Execution time: 1ms
    Proofs attached: 1
    Memory matches: 1

==============================================================================
  SCENARIO 5: HYPERFEDERATE - KGDB + SNOWFLAKE TPCH + BIGQUERY
==============================================================================

  Business Context:
  An analyst needs to correlate fraud patterns across multiple data sources:
  - KGDB: Knowledge graph with entity relationships
  - Snowflake TPCH_SF1: Transactional orders and customers
  - BigQuery: Insurance claims data

  HyperFederate provides VIRTUAL TABLES that map SQL to SPARQL predicates.
  The HyperMindAgent automatically discovers and uses these mappings.
  
[1] Virtual Table Mappings (from BRAIN ontology)...

    --------------------------------------------------------------------------
    Source      Table                       BRAIN Predicate     Columns
    --------------------------------------------------------------------------
    Snowflake   TPCH_SF1.ORDERS             brain:Order         O_ORDERKEY, O_CUSTKEY, O_TOTAL
    Snowflake   TPCH_SF1.CUSTOMER           brain:Customer      C_CUSTKEY, C_NAME, C_ACCTBAL
    Snowflake   TPCH_SF1.LINEITEM           brain:Transaction   L_ORDERKEY, L_SUPPKEY, L_EXTEN
    Snowflake   TPCH_SF1.SUPPLIER           brain:Supplier      S_SUPPKEY, S_NAME, S_ACCTBAL
    BigQuery    insurance_claims.claims     brain:Claim         claim_id, customer_id, amount
    --------------------------------------------------------------------------

[2] Federated Query (KGDB + Snowflake in single SPARQL)...

    Query:
    
        PREFIX brain: <http://brain.gonnect.ai/>
        PREFIX hf: <http://hyperfederate.gonnect.ai/>
    
        SELECT ?customer ?orderTotal ?riskScore ?fraudPattern WHERE {
          # From KGDB: Get fraud patterns
          ?customer a brain:Customer ;
                    brain:riskScore ?riskScore ;
                    brain:flaggedFor ?fraudPattern .
    
          # From Snowflake TPCH (via HyperFederate virtual table)
          SERVICE <snowflake://SNOWFLAKE_SAMPLE_DATA.TPCH_SF1> {
            ?order brain:customerId ?customer ;
                   brain:totalAmount ?orderTotal .
            FILTER(?orderTotal > 100000)
          }
    
          FILTER(?riskScore > 0.7)
        }
      

[3] Query Execution Plan...

    ------------------------------------------------------------
    Step 1: KGDB       -> Find customers with fraud patterns
    Step 2: Snowflake  -> Join with TPCH orders (via Federation)
    Step 3: Filter     -> riskScore > 0.7, orderTotal > 100K
    Step 4: Merge      -> Combine results with proof chain
    ------------------------------------------------------------

[4] Federated Results...

    ----------------------------------------------------------------------
    Customer    Order Total     Risk Score    Fraud Pattern
    ----------------------------------------------------------------------
    cust003     $193,846.25     0.85          CircularPayment
    cust004     $178,432.1      0.91          SupplierCollusion
    ----------------------------------------------------------------------

[5] HyperAgent Integration...

    When HyperMindAgent receives a query, it automatically:
    1. Discovers virtual tables from BRAIN ontology
    2. Generates federated SPARQL with SERVICE clauses
    3. Executes across KGDB + Snowflake + BigQuery
    4. Applies ThinkingReasoner for deduction
    5. Returns proof-carrying output

[6] Execution Mode...

    Mode: IN-MEMORY with RPC Proxy
    HyperFederate uses RpcFederationProxy
    - KGDB runs in-memory (Rust -> NAPI-RS)
    - Snowflake/BigQuery via RPC proxy bridge
    - Zero infrastructure for npm users

    Both modes are CERTIFIED and production-ready.

==============================================================================
  BONUS: DATALOG RULES (Custom Business Logic)
==============================================================================

  Beyond OWL/RDFS auto-generated rules, you can add custom Datalog rules:
  
[1] Custom fraud detection rules...

    Rules added:
      canReach(X,Y) :- transfers(X,Y)
      canReach(X,Z) :- transfers(X,Y), canReach(Y,Z)
      circularRing(X) :- canReach(X,Y), canReach(Y,X)
      fraudAlert(X) :- circularRing(X), highRisk(X)

[2] Evaluating rules to fixpoint...

    (Datalog evaluation - see ThinkingReasoner for production use)
    Concept: Custom rules extend OWL auto-generation
    fraudAlert(carol) would be derived from circularRing + highRisk

==============================================================================
  DEMO COMPLETE
==============================================================================

  BRAIN - Business Reasoning & AI Intelligence Network

  WHAT YOU JUST SAW:

  1. DEDUCTIVE REASONING (ThinkingReasoner - Rust Core)
     OWL/RDFS properties auto-generate Datalog rules. NOT probabilistic -
     logical derivation with proof-carrying outputs.

  2. CRYPTOGRAPHIC PROOFS (Curry-Howard Correspondence)
     Every conclusion has SHA-256 hash. Auditors verify the entire
     reasoning chain without re-running inference.

  3. THINKING GRAPH (Like Claude's Thinking)
     Visualize exactly how the agent derived each conclusion.
     Step-by-step derivation chain with premises.

  4. EPISODIC MEMORY (Agent Memory Ontology)
     Agent remembers past investigations. Memory persists across
     sessions. Finds similar patterns from history.

  5. RDF2VEC EMBEDDINGS (HNSW Similarity)
     384-dim vectors from graph structure. Semantic similarity
     without LLMs. Find fraud patterns by structure.

  6. HYPERFEDERATE (KGDB + Snowflake TPCH + BigQuery)
     Cross-database federation in single SPARQL query.
     Virtual tables map SQL columns to BRAIN predicates.
     Works in BOTH modes: In-Memory (RPC Proxy) + K8s (Cluster)

  7. DATALOG RULES (Custom Business Logic)
     Add your own rules beyond OWL auto-generation.
     circularRing(X) :- canReach(X,Y), canReach(Y,X)

  ALL AUTOMATED BY HYPERMINDAGENT:
  - Schema-aware query generation (no hallucination)
  - Automatic virtual table discovery
  - Deductive reasoning with proofs
  - Memory retrieval and storage
  - Audit trail for compliance

  NEXT STEPS:

  npm install rust-kgdb
  node examples/fraud-underwriting-reallife-demo.js

  # Optional: Enable full capabilities
  export ANTHROPIC_API_KEY=...     # Natural language
  export SNOWFLAKE_ACCOUNT=...     # TPCH federation
  export SNOWFLAKE_USER=...
  export SNOWFLAKE_PASSWORD=...

  DOCUMENTATION:

  - README.md           Quick start + thought-provoking intro
  - DESIGN.md           Architecture deep dive
  - ontology/           BRAIN + Agent Memory ontologies
  - examples/           More demos

  GitHub: https://github.com/gonnect-uk/rust-kgdb

==============================================================================

