// Turtle (Terse RDF Triple Language) Grammar
// Based on W3C Turtle 1.2 Specification
// https://www.w3.org/TR/rdf12-turtle/

// Main document
turtleDoc = { SOI ~ statement* ~ EOI }

statement = _{
    directive
  | triples ~ "."
}

directive = _{
    version
  | prefixID
  | base
  | sparqlPrefix
  | sparqlBase
}

// RDF 1.2 VERSION directive (can be VERSION or @version, with double or single quotes)
version = {
    ^"VERSION" ~ (STRING_LITERAL_QUOTE | STRING_LITERAL_SINGLE_QUOTE)
  | "@version" ~ (STRING_LITERAL_QUOTE | STRING_LITERAL_SINGLE_QUOTE) ~ "."
}

prefixID = { "@prefix" ~ PNAME_NS ~ IRIREF ~ "." }
base = { "@base" ~ IRIREF ~ "." }
sparqlPrefix = { ^"PREFIX" ~ PNAME_NS ~ IRIREF }
sparqlBase = { ^"BASE" ~ IRIREF }

// Triples (with optional RDF 1.2 annotation)
triples = {
    subject ~ predicateObjectList ~ annotation*
  | blankNodePropertyList ~ predicateObjectList? ~ annotation*
  | quotedTriple
}

predicateObjectList = {
    verb ~ objectList ~ annotation* ~ (";" ~ (verb ~ objectList ~ annotation*)?)*
}

objectList = { object ~ ("," ~ object)* }

// RDF 1.2 Annotation syntax - THREE forms:
// 1. {| :p :o |} - full annotation
// 2. ~ :id {| :p :o |} - annotation with ID
// 3. ~ :id - bare annotation (just ID)
annotation = {
    "{|" ~ predicateObjectList ~ "|}"
  | "~" ~ annotationId ~ "{|" ~ predicateObjectList ~ "|}"
  | "~" ~ annotationId?
}
annotationId = { iri | BlankNode }

// 'a' is W3C standard shorthand for rdf:type
verb = { predicate | keyword_a }
keyword_a = { "a" }

// IMPORTANT: BlankNode must come before iri to prevent _:id from matching as prefixed name
subject = { BlankNode | iri | collection | quotedTriple | blankNodePropertyList }
predicate = { iri }
object = { BlankNode | iri | collection | blankNodePropertyList | literal | quotedTriple | reifiedTriple }

// RDF-star support (RDF 1.2)
// NOTE: Inside quoted triples, objects are restricted (no collections, no blank node property lists)
// The annotation identifier ~id comes AFTER the object
quotedTriple = { "<<" ~ quotedTripleSubject ~ predicate ~ quotedTripleObject ~ occurrenceId? ~ ">>" }
quotedTripleSubject = { iri | BlankNode | quotedTriple }
quotedTripleObject = {
    iri
  | BlankNode
  | literal
  | quotedTriple
  | reifiedTriple
}

// RDF 1.2 triple occurrence identifier (comes after object in quoted triple)
// W3C spec: reifier ::= '~' (iri | BlankNode)?
// Use atomic tilde_bnode for ~_:id (no space), non-atomic for ~ :id (with space)
occurrenceId = { tilde_bnode | "~" ~ (iri | BlankNode)? }
tilde_bnode = @{ "~" ~ BLANK_NODE_LABEL }

// Annotation identifier for use in statement-level annotations
annotationIdentifier = { tilde_bnode | "~" ~ (iri | BlankNode)? }


// RDF 1.2 Reification syntax (triple term)
// NOTE: Can ONLY be used as object, never as subject
// But CAN be nested inside other reified triples
reifiedTriple = { "<<(" ~ quotedTripleSubject ~ predicate ~ quotedTripleObject ~ ")>>" }

// Literals
literal = {
    RDFLiteral
  | NumericLiteral
  | BooleanLiteral
}

blankNodePropertyList = { "[" ~ predicateObjectList ~ "]" }

collection = { "(" ~ object* ~ ")" }

NumericLiteral = { DOUBLE | DECIMAL | INTEGER }

RDFLiteral = { String ~ (LANGTAG | ("^^" ~ iri))? }

BooleanLiteral = { "true" | "false" }

String = _{
    STRING_LITERAL_LONG_SINGLE_QUOTE
  | STRING_LITERAL_LONG_QUOTE
  | STRING_LITERAL_QUOTE
  | STRING_LITERAL_SINGLE_QUOTE
}

iri = { IRIREF | PrefixedName }

PrefixedName = { PNAME_LN | PNAME_NS }

BlankNode = { BLANK_NODE_LABEL | ANON }

// Terminals
IRIREF = @{ "<" ~ (!(">"|  "<" | "\"" | "{" | "}" | "|" | "^" | "`" | "\\") ~ ANY)* ~ ">" }

// W3C Turtle spec: prefix cannot start with underscore (reserved for blank nodes)
PN_PREFIX_SIMPLE = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" | "-")* }
PNAME_NS = @{ PN_PREFIX_SIMPLE? ~ ":" }
PNAME_LN = @{ PNAME_NS ~ PN_LOCAL }

BLANK_NODE_LABEL = @{ "_:" ~ (PN_CHARS_U | ASCII_DIGIT) ~ ((PN_CHARS | ".")* ~ PN_CHARS)? }

// RDF 1.2: Language tags with optional direction (--ltr or --rtl)
LANGTAG = @{ "@" ~ ASCII_ALPHA+ ~ ("-" ~ (ASCII_ALPHANUMERIC)+)* ~ ("--" ~ ("ltr" | "rtl"))? }

INTEGER = @{ ("+" | "-")? ~ ASCII_DIGIT+ }

DECIMAL = @{ ("+" | "-")? ~ ASCII_DIGIT* ~ "." ~ ASCII_DIGIT+ }

DOUBLE = @{
    ("+" | "-")? ~ (
        ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* ~ EXPONENT
      | "." ~ ASCII_DIGIT+ ~ EXPONENT
      | ASCII_DIGIT+ ~ EXPONENT
    )
}

EXPONENT = @{ ^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+ }

STRING_LITERAL_QUOTE = @{ "\"" ~ (!(("\"" | "\\" | "\n" | "\r")) ~ ANY | ECHAR | UCHAR)* ~ "\"" }

STRING_LITERAL_SINGLE_QUOTE = @{ "'" ~ (!(("'" | "\\" | "\n" | "\r")) ~ ANY | ECHAR | UCHAR)* ~ "'" }

// Triple-quoted strings: match any char except ''' or """ terminator
// Use explicit character classes to avoid backtracking
STRING_LITERAL_LONG_SINGLE_QUOTE = @{ "'''" ~ LONG_SINGLE_CHAR* ~ "'''" }
LONG_SINGLE_CHAR = @{ !("'''") ~ ("''" | "'" | ECHAR | UCHAR | !("'" | "\\") ~ ANY) }

STRING_LITERAL_LONG_QUOTE = @{ "\"\"\"" ~ LONG_QUOTE_CHAR* ~ "\"\"\"" }
LONG_QUOTE_CHAR = @{ !("\"\"\"") ~ ("\"\"" | "\"" | ECHAR | UCHAR | !("\"" | "\\") ~ ANY) }

UCHAR = @{ "\\u" ~ HEX_DIGIT{4} | "\\U" ~ HEX_DIGIT{8} }

ECHAR = @{ "\\" ~ ("t" | "b" | "n" | "r" | "f" | "\"" | "'") }

ANON = { "[" ~ WS* ~ "]" }

PN_CHARS_BASE = @{
    ASCII_ALPHA |
    '\u{00C0}'..'\u{00D6}' |
    '\u{00D8}'..'\u{00F6}' |
    '\u{00F8}'..'\u{02FF}' |
    '\u{0370}'..'\u{037D}' |
    '\u{037F}'..'\u{1FFF}' |
    '\u{200C}'..'\u{200D}' |
    '\u{2070}'..'\u{218F}' |
    '\u{2C00}'..'\u{2FEF}' |
    '\u{3001}'..'\u{D7FF}' |
    '\u{F900}'..'\u{FDCF}' |
    '\u{FDF0}'..'\u{FFFD}'
}

PN_CHARS_U = @{ PN_CHARS_BASE | "_" }

PN_CHARS = @{
    PN_CHARS_U |
    "-" |
    ASCII_DIGIT |
    '\u{00B7}'..'\u{00B7}' |
    '\u{0300}'..'\u{036F}' |
    '\u{203F}'..'\u{2040}'
}

PN_PREFIX = @{ PN_CHARS_BASE ~ ((PN_CHARS | ".")* ~ PN_CHARS)? }

PN_LOCAL = @{
    (PN_CHARS_U | ":" | ASCII_DIGIT | PLX) ~ (PN_CHARS | "." | ":" | PLX)*
}

PLX = @{ PERCENT | PN_LOCAL_ESC }

PERCENT = @{ "%" ~ HEX_DIGIT ~ HEX_DIGIT }

HEX_DIGIT = @{ ASCII_DIGIT | 'A'..'F' | 'a'..'f' }

PN_LOCAL_ESC = @{ "\\" ~ ("_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%") }

// Whitespace and comments
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }

WS = _{ WHITESPACE+ }

COMMENT = _{ "#" ~ (!("\r" | "\n") ~ ANY)* }
