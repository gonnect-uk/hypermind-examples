/**
 * Euroleague Basketball Knowledge Graph + HyperMindAgent
 *
 * Based on: https://medium.com/@skontopo2009/representing-euroleague-play-by-play-data-as-a-knowledge-graph-6397534cdd75
 * Data Model: https://github.com/andrewstellman/pbprdf (Play-by-Play RDF ontology)
 *
 * This example demonstrates:
 * - Loading RDF knowledge graphs (inline or from HTTP URLs)
 * - OWL properties: SymmetricProperty, TransitiveProperty
 * - Natural language queries with HyperMindAgent
 * - Deductive reasoning with derivation chains
 *
 * ## Data Sources for Euroleague Play-by-Play
 *
 * ### Option 1: CSV Dataset (Download and convert to RDF)
 * OpenDataBay Euroleague PBP Statistics (2021-22 season):
 * https://www.opendatabay.com/data/euroleague-advanced-pbp
 *
 * ### Option 2: Python API (Live data)
 * pip install euroleague-api
 *
 * ```python
 * from euroleague_api.play_by_play_data import PlayByPlay
 * pbp = PlayByPlay()
 * df = pbp.get_game_play_by_play(season, game_code)
 * # Convert df to RDF triples and save as TTL
 * ```
 *
 * ### Option 3: pbprdf Ontology (RDF schema for basketball)
 * https://github.com/andrewstellman/pbprdf
 *
 * Run: OPENAI_API_KEY=your-key node examples/euroleague-basketball-agent.js
 *      (Also works without API key using schema-based generation)
 */

const { GraphDB, HyperMindAgent } = require('rust-kgdb')

// ============================================================================
// URL Loading Helper - GraphDB supports loadTtl, we fetch and pass content
// ============================================================================

/**
 * Load RDF data from a URL into GraphDB
 * @param {GraphDB} db - GraphDB instance
 * @param {string} url - URL to fetch (TTL, NT, or other RDF format)
 * @param {string|null} graphName - Optional named graph
 * @returns {Promise<number>} - Number of triples loaded
 *
 * @example
 * // Load from GitHub
 * await loadFromUrl(db, 'https://raw.githubusercontent.com/.../game.ttl')
 *
 * // Load from local server
 * await loadFromUrl(db, 'http://localhost:3000/euroleague.ttl')
 *
 * // Load from LinkedData endpoint
 * await loadFromUrl(db, 'https://dbpedia.org/resource/EuroLeague.ttl')
 */
async function loadFromUrl(db, url, graphName = null) {
  console.log(`    Fetching: ${url}`)
  const response = await fetch(url)
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
  }
  const content = await response.text()
  const before = db.countTriples()
  db.loadTtl(content, graphName)
  const after = db.countTriples()
  return after - before
}

// ============================================================================
// Data Source URLs
// ============================================================================

const DATA_SOURCES = {
  // pbprdf: Basketball play-by-play RDF ontology
  pbprdf: {
    ontology: 'https://raw.githubusercontent.com/andrewstellman/pbprdf/master/ontology/pbprdf.ttl',
    repo: 'https://github.com/andrewstellman/pbprdf'
  },

  // OpenDataBay: Euroleague CSV data (needs conversion to RDF)
  opendatabay: {
    csv: 'https://www.opendatabay.com/data/euroleague-advanced-pbp',
    description: 'Euroleague Advanced PBP Statistics (2021-22 season)'
  },

  // Python API for live data
  euroleagueApi: {
    pypi: 'https://pypi.org/project/euroleague-api/',
    install: 'pip install euroleague-api'
  }
}

// Data is loaded from data/euroleague-game.ttl (generated by scripts/euroleague-to-ttl.py)

async function main() {
  console.log('='.repeat(70))
  console.log('  EUROLEAGUE BASKETBALL KNOWLEDGE GRAPH')
  console.log('  HyperMindAgent with Deductive Reasoning')
  console.log('='.repeat(70))
  console.log()
  console.log('Source: https://medium.com/@skontopo2009/')
  console.log('        representing-euroleague-play-by-play-data-as-a-knowledge-graph')
  console.log('Data Model: https://github.com/andrewstellman/pbprdf')
  console.log()

  // 1. Load Knowledge Graph from euroleague-api data
  console.log('[1] Loading Play-by-Play Knowledge Graph...')
  const db = new GraphDB('http://euroleague.net/')

  const fs = require('fs')
  const path = require('path')
  const dataPath = path.join(__dirname, '..', 'data', 'euroleague-game.ttl')

  if (!fs.existsSync(dataPath)) {
    console.error(`ERROR: Data file not found: ${dataPath}`)
    console.error('Run: uv run --with euroleague-api python3 scripts/euroleague-to-ttl.py')
    process.exit(1)
  }

  const ttlData = fs.readFileSync(dataPath, 'utf-8')
  db.loadTtl(ttlData, null)

  const tripleCount = db.countTriples()
  console.log(`    Source: euroleague-api (pip install euroleague-api)`)
  console.log(`    Triples: ${tripleCount}`)
  console.log()

  // 2. Query Teams
  console.log('[2] Teams in the Graph:')
  const teamsQ = `SELECT ?team ?label WHERE {
    ?team <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://euroleague.net/ontology#Team> .
    ?team <http://www.w3.org/2000/01/rdf-schema#label> ?label .
  }`
  const teams = db.querySelect(teamsQ)
  for (const r of teams) {
    const label = r.bindings?.label || r.label
    console.log(`    - ${clean(label)}`)
  }
  console.log()

  // 3. Query Players
  console.log('[3] Players and Teams:')
  const playersQ = `SELECT ?name ?team WHERE {
    ?p <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://euroleague.net/ontology#Player> .
    ?p <http://www.w3.org/2000/01/rdf-schema#label> ?name .
    ?p <http://euroleague.net/ontology#playsFor> ?team .
  }`
  const players = db.querySelect(playersQ)
  for (const r of players) {
    const name = clean(r.bindings?.name || r.name)
    const team = extractLast(r.bindings?.team || r.team)
    console.log(`    - ${name} (${team})`)
  }
  console.log()

  // 4. Play-by-Play Events
  console.log('[4] Play-by-Play Events:')
  const eventsQ = `SELECT ?label ?player WHERE {
    ?e <http://www.w3.org/2000/01/rdf-schema#label> ?label .
    ?e <http://euroleague.net/ontology#player> ?player .
  }`
  const events = db.querySelect(eventsQ)
  for (const r of events) {
    const label = clean(r.bindings?.label || r.label)
    const player = extractLast(r.bindings?.player || r.player)
    console.log(`    - ${label} by ${player}`)
  }
  console.log()

  // 5. Teammate Relationships (SymmetricProperty)
  console.log('[5] Teammate Relationships (owl:SymmetricProperty):')
  const tmQ = `SELECT ?a ?b WHERE {
    ?a <http://euroleague.net/ontology#teammateOf> ?b .
  }`
  const teammates = db.querySelect(tmQ)
  for (const r of teammates) {
    const a = extractLast(r.bindings?.a || r.a)
    const b = extractLast(r.bindings?.b || r.b)
    console.log(`    ${a} <-> ${b}`)
  }
  console.log()
  console.log('    Deduction: If James teammateOf Okobo, then Okobo teammateOf James')
  console.log()

  // 6. Assist Chain (TransitiveProperty)
  console.log('[6] Assist Chain (owl:TransitiveProperty):')
  const assistQ = `SELECT ?player ?by WHERE {
    ?player <http://euroleague.net/ontology#assistedBy> ?by .
  }`
  const assists = db.querySelect(assistQ)
  for (const r of assists) {
    const player = extractLast(r.bindings?.player || r.player)
    const by = extractLast(r.bindings?.by || r.by)
    console.log(`    ${player} <- assisted by <- ${by}`)
  }
  console.log()
  console.log('    Deduction: If Nunn assistedBy Sloukas, and X assistedBy Nunn,')
  console.log('               then X assistedBy Sloukas (transitive chain)')
  console.log()

  // 7. HyperMindAgent with ThinkingReasoner
  console.log('[7] Creating HyperMindAgent with ThinkingReasoner...')
  const agent = new HyperMindAgent({
    name: 'euroleague-analyst',
    kg: db,
    apiKey: process.env.OPENAI_API_KEY,
    model: 'gpt-4o'
  })

  // Load ontology for automatic rule generation (OWL -> Datalog)
  const ontology = `
    @prefix owl: <http://www.w3.org/2002/07/owl#> .
    @prefix euro: <http://euroleague.net/ontology#> .
    @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

    euro:teammateOf a owl:SymmetricProperty ;
        rdfs:label "teammate relationship - automatically derives reverse" .
    euro:assistedBy a owl:TransitiveProperty ;
        rdfs:label "assist chain - derives transitive closure" .
    euro:playsFor rdfs:domain euro:Player ;
        rdfs:range euro:Team .
  `
  agent.loadOntology(ontology)

  // Add observations from the knowledge graph
  console.log('    Loading observations into ThinkingReasoner...')

  // Observe teammate relationships
  for (const r of teammates) {
    const a = extractLast(r.bindings?.a || r.a)
    const b = extractLast(r.bindings?.b || r.b)
    agent.observe(`${a} is teammate of ${b}`, {
      subject: a,
      predicate: 'teammateOf',
      object: b
    })
  }

  // Observe assist chains
  for (const r of assists) {
    const player = extractLast(r.bindings?.player || r.player)
    const by = extractLast(r.bindings?.by || r.by)
    agent.observe(`${player} was assisted by ${by}`, {
      subject: player,
      predicate: 'assistedBy',
      object: by
    })
  }

  // Observe clutch shots
  const clutchQ = `SELECT ?player ?label WHERE {
    ?e <http://euroleague.net/ontology#isClutch> "true" .
    ?e <http://euroleague.net/ontology#player> ?player .
    ?e <http://www.w3.org/2000/01/rdf-schema#label> ?label .
  }`
  const clutchShots = db.querySelect(clutchQ)
  for (const r of clutchShots) {
    const player = extractLast(r.bindings?.player || r.player)
    const label = clean(r.bindings?.label || r.label)
    agent.observe(`CLUTCH: ${player} made clutch shot - ${label}`, {
      subject: player,
      predicate: 'madeClutchShot',
      object: 'true'
    })
  }

  // Run deduction to derive new facts
  console.log('    Running deductive reasoning...')
  const deduction = agent.deduce()

  console.log(`    Agent: ${agent.name}`)
  console.log(`    LLM: ${process.env.OPENAI_API_KEY ? 'OpenAI' : 'None (schema-based)'}`)

  const stats = agent.getReasoningStats()
  console.log(`    Observations: ${stats.events}`)
  console.log(`    Derived Facts: ${stats.facts}`)
  console.log(`    Rules Applied: ${stats.rules}`)
  console.log()

  // 8. Use Case Queries for Different Personas
  // Based on: https://medium.com/@skontopo2009/representing-euroleague-play-by-play-data-as-a-knowledge-graph
  console.log('[8] Use Case Queries by Persona:')
  console.log()
  console.log('Natural Language -> SPARQL (Generated by HyperMindAgent)')
  console.log()

  const useCases = [
    // Journalists: Uncover nuanced storylines
    {
      persona: 'JOURNALIST',
      question: 'Who made the defensive steals in this game?',
      value: 'Uncover storylines beyond surface-level stats'
    },
    // Teams/Coaching: Strategic decision-making
    {
      persona: 'COACH',
      question: 'Which players distributed the ball best with assists?',
      value: 'Identify team chemistry for strategic planning'
    },
    // Analysts: Build robust models
    {
      persona: 'ANALYST',
      question: 'Who scored the most points in this game?',
      value: 'Enriched interconnected data for modeling'
    },
    // Fans: Explore interactively
    {
      persona: 'FAN',
      question: 'Who are the teammates of Lessort?',
      value: 'Interactive exploration of team dynamics'
    },
    // Researchers: ML/semantic web testbed
    {
      persona: 'RESEARCHER',
      question: 'Show the symmetric teammate relationships',
      value: 'OWL SymmetricProperty inference for ML features'
    }
  ]

  for (const uc of useCases) {
    console.log('-'.repeat(60))
    console.log(`${uc.persona}: "${uc.question}"`)
    console.log(`VALUE: ${uc.value}`)
    console.log('-'.repeat(60))

    try {
      // Call HyperMindAgent with natural language question
      const result = await agent.call(uc.question)

      // Show the GENERATED SPARQL (what the agent produces from natural language)
      const sparqlQueries = result.explanation?.sparql_queries || []
      if (sparqlQueries.length > 0) {
        console.log()
        console.log('GENERATED SPARQL:')
        console.log('```sparql')
        console.log(sparqlQueries[0].query)
        console.log('```')
        console.log(`  Executed in ${result.explanation?.execution_time_ms || 0}ms, ${sparqlQueries[0].resultCount} results`)
      }
      console.log()

      // Show answer
      const answer = result.answer || result.response || result.text
      if (answer) {
        console.log('ANSWER:', answer)
      } else {
        console.log('RESULTS:', `Found ${result.raw_results?.[0]?.result?.length || result.results?.length || 0} bindings`)
      }

      // Show reasoning stats
      if (result.reasoningStats) {
        console.log()
        console.log('REASONING:')
        console.log(`  Observations: ${result.reasoningStats.events || 0}`)
        console.log(`  Derived Facts: ${result.reasoningStats.facts || 0}`)
        console.log(`  Rules: ${result.reasoningStats.rules || 0}`)
      }

      // Show derivation chain (the proof)
      if (result.thinkingGraph?.derivationChain?.length > 0) {
        console.log()
        console.log('PROOF (Derivation Chain):')
        for (const s of result.thinkingGraph.derivationChain.slice(0, 5)) {
          const rule = s.rule || 'OBSERVATION'
          const fact = s.conclusion || s.fact || ''
          console.log(`  Step ${s.step}: [${rule}] ${fact}`)
        }
      }

      // Debug: Show available keys in result (for development)
      // console.log('  DEBUG result keys:', Object.keys(result))
    } catch (e) {
      console.log(`  Error: ${e.message}`)
    }
    console.log()
  }

  // 9. Thinking Graph Visualization
  console.log('[9] Thinking Graph (Explainable AI):')
  console.log()

  const thinkingGraph = agent.getThinkingGraph()

  if (thinkingGraph.nodes && thinkingGraph.nodes.length > 0) {
    console.log('  EVIDENCE NODES:')
    for (const node of thinkingGraph.nodes.slice(0, 8)) {
      const icon = {
        'OBSERVATION': '  [OBS]',
        'HYPOTHESIS': '  [HYP]',
        'INFERENCE': '  [INF]'
      }[node.type] || '  [EVT]'
      const label = node.label || node.id
      console.log(`${icon} ${label}`)
    }
    console.log()
  }

  if (thinkingGraph.derivationChain && thinkingGraph.derivationChain.length > 0) {
    console.log('  DERIVATION CHAIN (Proof Steps):')
    for (const step of thinkingGraph.derivationChain.slice(0, 8)) {
      console.log(`  Step ${step.step}: [${step.rule}] ${step.conclusion}`)
      if (step.premises && step.premises.length > 0) {
        console.log(`         Premises: ${step.premises.join(', ')}`)
      }
    }
    console.log()
  }

  console.log('  VALUE: Every conclusion traces back to ground truth observations.')
  console.log('         No hallucinations - only provable facts.')
  console.log()

  // 10. Summary
  console.log('='.repeat(70))
  console.log('  SUMMARY')
  console.log('='.repeat(70))
  console.log()
  console.log(`  Knowledge Graph: ${tripleCount} triples`)
  console.log(`  Teams: ${teams.length}`)
  console.log(`  Players: ${players.length}`)
  console.log(`  Events: ${events.length}`)
  console.log(`  Teammate links: ${teammates.length}`)
  console.log()
  console.log('  OWL Properties enable automatic reasoning:')
  console.log('  - SymmetricProperty: A rel B => B rel A')
  console.log('  - TransitiveProperty: A rel B, B rel C => A rel C')
  console.log()
  console.log('  DATA SOURCES (for production use):')
  console.log('  1. euroleague-api (Python): pip install euroleague-api')
  console.log('     Best option - same data source as the Medium article')
  console.log('  2. OpenDataBay CSV: opendatabay.com/data/euroleague-advanced-pbp')
  console.log('  3. pbprdf ontology: github.com/andrewstellman/pbprdf')
  console.log()
  console.log('  See scripts/euroleague-to-ttl.py for data conversion example')
  console.log()
  console.log('  For K8s deployment: gonnect.hypermind@gmail.com')
  console.log()
}

function clean(s) {
  if (!s) return ''
  return String(s).replace(/^"|"$/g, '')
}

function extractLast(s) {
  if (!s) return ''
  s = String(s).replace(/^<|>$/g, '')
  const i = Math.max(s.lastIndexOf('#'), s.lastIndexOf('/'))
  return i >= 0 ? s.substring(i + 1) : s
}

main().catch(console.error)
