# rust-kgdb v0.1.9 Roadmap - Performance Optimization & Empirical Verification

**Target Release**: 2-3 weeks from v0.1.8
**Focus**: Empirical benchmarks, SIMD optimizations, Profile-Guided Optimization (PGO)
**Goal**: Achieve **50-100x verified speedup** for star queries, beat RDFox in all metrics

---

## ðŸŽ¯ Primary Objectives

1. âœ… **Empirical WCOJ Benchmarks** - Measure actual performance gains
2. âœ… **SIMD Optimizations** - 2-4x additional speedup for trie operations
3. âœ… **Profile-Guided Optimization (PGO)** - Compiler-guided hot path optimization
4. âœ… **Complete SDK Publishing** - PyPI + Maven Central
5. âœ… **Documentation** - Verified performance claims with real data

---

## ðŸ“Š Phase 1: Empirical WCOJ Benchmarks (Week 1)

### Objectives
- Measure **actual** WCOJ vs nested loop speedup
- Verify theoretical 50-100x claims with real data
- Identify performance bottlenecks
- Document real-world query performance

### Implementation Plan

#### 1.1 LUBM Benchmark Suite

**File**: `crates/sparql/benches/lubm_wcoj_benchmark.rs`

**Dataset**:
```
LUBM(1)   - 3,272 triples (baseline)
LUBM(10)  - 32,720 triples
LUBM(100) - 327,200 triples
```

**Queries to Benchmark**:

```rust
// Q1: 3-way star query (find students with name, department, and type)
SELECT ?student ?name ?dept WHERE {
  ?student ub:name ?name .
  ?student ub:memberOf ?dept .
  ?student rdf:type ub:Student .
}

// Q2: 4-way star query (add university)
SELECT ?student ?name ?dept ?uni WHERE {
  ?student ub:name ?name .
  ?student ub:memberOf ?dept .
  ?student rdf:type ub:Student .
  ?dept ub:subOrganizationOf ?uni .
}

// Q3: 5-way star query (add advisor)
SELECT ?student ?name ?dept ?uni ?advisor WHERE {
  ?student ub:name ?name .
  ?student ub:memberOf ?dept .
  ?student rdf:type ub:Student .
  ?dept ub:subOrganizationOf ?uni .
  ?student ub:advisor ?advisor .
}

// Q4: Complex join (coworker pattern)
SELECT ?prof1 ?prof2 ?dept WHERE {
  ?prof1 ub:worksFor ?dept .
  ?prof2 ub:worksFor ?dept .
  ?prof1 ub:name ?name1 .
  ?prof2 ub:name ?name2 .
  FILTER(?prof1 != ?prof2)
}

// Q5: Chain query (advisor teaches course student takes)
SELECT ?student ?advisor ?course WHERE {
  ?student ub:advisor ?advisor .
  ?advisor ub:teacherOf ?course .
  ?student ub:takesCourse ?course .
}
```

**Measurement Methodology**:
1. Warm-up: 10 iterations (discard)
2. Measurement: 100 iterations per query
3. Statistics: mean, median, std dev, min, max
4. Comparison: WCOJ vs nested loop (same query, different execution path)

**Success Criteria**:
- Star queries (3-way): **30-50x** speedup minimum
- Star queries (4-way): **40-80x** speedup minimum
- Star queries (5-way): **50-100x** speedup minimum
- Complex joins: **100-500x** speedup minimum
- Chain queries: **10-20x** speedup minimum

#### 1.2 SP2Bench Benchmark Suite

**Queries**:
- Q1: Simple pattern (baseline)
- Q2: Star query variant
- Q3: Complex join
- Q4: OPTIONAL patterns
- Q5: UNION patterns

**Expected Results**:
- Document speedup per query type
- Identify queries where WCOJ excels
- Identify queries where nested loop is competitive

#### 1.3 Deliverables

**Files**:
- `crates/sparql/benches/lubm_wcoj_benchmark.rs` - Criterion benchmark suite
- `docs/benchmarks/WCOJ_EMPIRICAL_RESULTS.md` - Comprehensive results
- `docs/benchmarks/PERFORMANCE_COMPARISON.md` - vs RDFox, Apache Jena

**Metrics to Report**:
| Query Type | Dataset | WCOJ Time | Nested Loop Time | Speedup | vs RDFox |
|------------|---------|-----------|------------------|---------|----------|
| 3-way star | LUBM(10) | X Âµs | Y Âµs | Zx | Nx faster |
| 4-way star | LUBM(10) | ... | ... | ... | ... |
| 5-way star | LUBM(100) | ... | ... | ... | ... |

---

## âš¡ Phase 2: SIMD Optimizations (Week 2)

### Objectives
- Vectorize trie construction (2-3x faster)
- Vectorize LeapFrog intersection (1.5-2x faster)
- Overall: **2-4x additional speedup** on top of WCOJ

### Implementation Plan

#### 2.1 SIMD Trie Construction

**File**: `crates/wcoj/src/trie_simd.rs`

**Strategy**:
```rust
#[cfg(target_arch = "x86_64")]
use std::arch::x86_64::*;

/// SIMD-accelerated trie path insertion
pub struct SimdTrie<'a> {
    root: TrieNode<'a>,
    depth: usize,
    // SIMD-aligned buffers
    node_buffer: Vec<Node<'a>>,  // 64-byte aligned
}

impl<'a> SimdTrie<'a> {
    /// Insert paths in batches using SIMD
    pub fn batch_insert(&mut self, paths: &[Vec<Node<'a>>]) {
        // Process 4 paths at a time with AVX2
        for chunk in paths.chunks(4) {
            unsafe {
                self.simd_insert_quad(chunk);
            }
        }
    }

    #[cfg(target_arch = "x86_64")]
    unsafe fn simd_insert_quad(&mut self, paths: &[Vec<Node<'a>>]) {
        // Use AVX2 to compare 4 nodes simultaneously
        // Vectorized node comparison + branch prediction
        // ...
    }
}
```

**Optimizations**:
1. **Batch insertion**: Process 4-8 paths at a time
2. **Vectorized comparison**: AVX2 for node equality
3. **Prefetching**: `_mm_prefetch` for next nodes
4. **Aligned allocation**: 64-byte alignment for cache lines

**Expected Speedup**: 2-3x for trie construction

#### 2.2 SIMD LeapFrog Intersection

**File**: `crates/wcoj/src/leapfrog_simd.rs`

**Strategy**:
```rust
/// SIMD-accelerated LeapFrog iterator
pub struct SimdLeapfrogIterator<'a> {
    iterators: Vec<TrieIterator<'a>>,
    current: Vec<Node<'a>>,  // 64-byte aligned
    // SIMD comparison masks
    cmp_mask: __m256i,
}

impl<'a> SimdLeapfrogIterator<'a> {
    /// Seek all iterators to target using SIMD
    unsafe fn simd_seek_all(&mut self, target: &Node<'a>) {
        // Use AVX2 to seek 4 iterators in parallel
        // Vectorized comparison + conditional seek
        // ...
    }

    /// Find minimum using SIMD horizontal min
    unsafe fn simd_min(&self) -> Option<&Node<'a>> {
        // Use _mm256_min_epi64 for horizontal minimum
        // ...
    }
}
```

**Optimizations**:
1. **Parallel seek**: Seek 4 iterators simultaneously
2. **Vectorized min**: SIMD horizontal minimum
3. **Batch comparison**: Compare 8 nodes at once
4. **Prefetch**: Lookahead for next trie nodes

**Expected Speedup**: 1.5-2x for LeapFrog execution

#### 2.3 Auto-Vectorization Hints

**Compiler Flags**:
```toml
[profile.release]
rustflags = [
    "-C", "target-cpu=native",
    "-C", "target-feature=+avx2,+fma",
]
```

**Code Annotations**:
```rust
#[inline(always)]
#[target_feature(enable = "avx2")]
unsafe fn vectorized_path_insert(...) { ... }
```

#### 2.4 Deliverables

**Files**:
- `crates/wcoj/src/trie_simd.rs` - SIMD trie implementation
- `crates/wcoj/src/leapfrog_simd.rs` - SIMD LeapFrog implementation
- `crates/wcoj/benches/simd_benchmark.rs` - SIMD vs scalar comparison

**Success Criteria**:
- Trie construction: **2-3x faster**
- LeapFrog execution: **1.5-2x faster**
- Overall WCOJ: **2-4x faster** than v0.1.8
- No regressions on non-SIMD platforms (ARM, RISC-V)

---

## ðŸ”¥ Phase 3: Profile-Guided Optimization (PGO) (Week 3)

### Objectives
- Identify hot paths with real-world query workload
- Apply compiler-guided optimizations
- Target: **450K+ triples/sec** bulk insert (from 146K)
- Target: **sub-1Âµs** triple lookups (from 2.78Âµs)

### Implementation Plan

#### 3.1 PGO Build Pipeline

**Step 1: Instrument Build**
```bash
# Build with PGO instrumentation
RUSTFLAGS="-C profile-generate=/tmp/pgo-data" \
cargo build --release
```

**Step 2: Generate Profile Data**
```bash
# Run representative workload
./target/release/benchmark_suite
./target/release/lubm_import_100k
./target/release/sparql_query_workload
```

**Step 3: Optimized Build**
```bash
# Merge profile data
llvm-profdata merge -o /tmp/pgo-data/merged.profdata /tmp/pgo-data/*.profraw

# Build with PGO optimizations
RUSTFLAGS="-C profile-use=/tmp/pgo-data/merged.profdata -C llvm-args=-pgo-warn-missing-function" \
cargo build --release
```

#### 3.2 Hot Path Identification

**Tools**:
- `cargo flamegraph` - Visualize hot paths
- `perf record` + `perf report` - Linux profiling
- `samply` - High-resolution profiler

**Expected Hot Paths**:
1. `Dictionary::intern()` - String interning
2. `QuadStore::find()` - Pattern matching
3. `LeapfrogJoin::execute()` - WCOJ execution
4. `TrieNode::seek()` - Trie traversal
5. `evaluate_bgp()` - BGP evaluation

#### 3.3 Targeted Optimizations

**Dictionary Interning**:
```rust
// Before: HashMap lookup
pub fn intern(&self, s: &str) -> &str {
    self.map.get_or_insert(s)
}

// After: Lock-free with atomic CAS
pub fn intern(&self, s: &str) -> &str {
    // Fast path: read-only atomic load
    if let Some(cached) = self.try_get_cached(s) {
        return cached;
    }
    // Slow path: CAS insertion
    self.cas_insert(s)
}
```

**Index Scanning**:
```rust
// Before: Iterator-based
pub fn scan(&self, pattern: &QuadPattern) -> impl Iterator<...> {
    self.backend.scan(prefix).filter(...)
}

// After: Vectorized batch scanning
pub fn scan_batch(&self, pattern: &QuadPattern) -> Vec<Quad> {
    // SIMD-accelerated filtering
    self.backend.scan_vectorized(prefix, 1024)
}
```

#### 3.4 Deliverables

**Files**:
- `scripts/pgo_build.sh` - Automated PGO build script
- `docs/performance/PGO_RESULTS.md` - Before/after comparison

**Success Criteria**:
- Bulk insert: **450K+ triples/sec** (3x improvement)
- Triple lookup: **<1Âµs** (2.8x improvement)
- Complex queries: **15-20% faster** than v0.1.8

---

## ðŸ“¦ Phase 4: Complete SDK Publishing

### 4.1 Python SDK (PyPI)

**Status**: Built and ready (`dist/rust_kgdb-0.1.8.tar.gz`)

**Publishing Steps**:
```bash
cd sdks/python
twine upload dist/rust_kgdb-0.1.8*
```

**Verification**:
```bash
pip install rust-kgdb==0.1.8
python3 -c "from rust_kgdb_py import GraphDb; print(GraphDb('test').get_version())"
```

### 4.2 Kotlin SDK (Maven Central)

**Status**: 4/5 tests passing (CONSTRUCT query issue)

**Fix Required**:
- Debug SPARQL parser template extraction
- Ensure CONSTRUCT queries return non-zero triples

**Publishing Steps**:
```bash
cd sdks/kotlin
./gradlew publishToMavenCentral --no-configuration-cache
```

**Verification**:
```kotlin
// build.gradle.kts
dependencies {
    implementation("uk.gonnect:rust-kgdb:0.1.8")
}
```

### 4.3 npm Package (Already Published)

**Status**: âœ… LIVE at https://www.npmjs.com/package/rust-kgdb

**Verification**:
```bash
npm view rust-kgdb version  # 0.1.8
```

---

## ðŸ“š Phase 5: Documentation Updates

### 5.1 Benchmark Results Documentation

**File**: `docs/benchmarks/WCOJ_EMPIRICAL_RESULTS.md`

**Content**:
- Detailed benchmark methodology
- Raw data (JSON/CSV format)
- Statistical analysis (mean, median, std dev)
- Graphs: speedup charts, performance curves
- Comparison tables: vs RDFox, Apache Jena

### 5.2 SIMD Implementation Guide

**File**: `docs/technical/SIMD_IMPLEMENTATION.md`

**Content**:
- Architecture overview (AVX2, NEON, fallback)
- Performance characteristics
- Platform compatibility matrix
- Developer guide: how to add SIMD optimizations

### 5.3 PGO Build Guide

**File**: `docs/performance/PGO_BUILD_GUIDE.md`

**Content**:
- Complete PGO workflow
- Profile data generation strategies
- Benchmark-driven optimization
- Performance gains breakdown

---

## ðŸŽ¯ Success Metrics

### Performance Targets

| Metric | v0.1.8 (Current) | v0.1.9 (Target) | Improvement |
|--------|------------------|-----------------|-------------|
| **Star Query (3-way)** | Nested loop O(nÂ³) | WCOJ **30-50x faster** | âœ… 30-50x |
| **Star Query (5-way)** | Nested loop O(nâµ) | WCOJ **50-100x faster** | âœ… 50-100x |
| **Complex Join** | Nested loop O(nâ´) | WCOJ **100-500x faster** | âœ… 100-500x |
| **Bulk Insert** | 146K/sec | **450K+/sec** | âœ… 3x |
| **Triple Lookup** | 2.78 Âµs | **<1 Âµs** | âœ… 2.8x |
| **SIMD Speedup** | N/A | **2-4x additional** | âœ… 2-4x |

### Quality Targets

| Metric | Target |
|--------|--------|
| **Test Coverage** | 100% (all tests green) |
| **Benchmark Suite** | 20+ queries across LUBM + SP2Bench |
| **Documentation** | Complete (benchmarks, SIMD, PGO) |
| **SDK Publishing** | PyPI âœ…, Maven Central âœ…, npm âœ… |
| **Regression Tests** | 0 failures |

---

## ðŸ“… Timeline

**Week 1**: Empirical benchmarks
- Day 1-2: LUBM benchmark suite implementation
- Day 3-4: SP2Bench benchmark suite implementation
- Day 5-7: Data collection, analysis, documentation

**Week 2**: SIMD optimizations
- Day 8-10: SIMD trie construction
- Day 11-13: SIMD LeapFrog intersection
- Day 14: Integration testing, benchmarking

**Week 3**: PGO + SDK publishing
- Day 15-17: PGO instrumentation, profiling, optimization
- Day 18-19: Kotlin SDK fix + Maven Central publishing
- Day 20-21: Final testing, documentation, release

---

## ðŸš€ Release Checklist

### Code
- [ ] LUBM benchmark suite complete (20+ queries)
- [ ] SP2Bench benchmark suite complete
- [ ] SIMD trie construction implemented
- [ ] SIMD LeapFrog intersection implemented
- [ ] PGO build pipeline automated
- [ ] All tests passing (100% green)
- [ ] Zero regressions

### Documentation
- [ ] `WCOJ_EMPIRICAL_RESULTS.md` complete
- [ ] `SIMD_IMPLEMENTATION.md` complete
- [ ] `PGO_BUILD_GUIDE.md` complete
- [ ] CHANGELOG.md updated with v0.1.9 entry
- [ ] README.md updated with verified performance claims

### Publishing
- [ ] Python SDK published to PyPI (rust-kgdb 0.1.9)
- [ ] Kotlin SDK published to Maven Central
- [ ] npm package updated (rust-kgdb 0.1.9)
- [ ] GitHub release created with binaries
- [ ] Blog post: "rust-kgdb v0.1.9: Verified 50-100x WCOJ Speedup"

---

## ðŸŽ“ Learning & Innovation

### Research Areas
1. **Adaptive query optimization** - Learn from query history
2. **Parallel WCOJ** - Multi-threaded LeapFrog execution
3. **GPU acceleration** - CUDA-based trie operations
4. **Distributed WCOJ** - Federated query execution

### Future Roadmap (v0.2.0+)
- Advanced cost-based optimization (machine learning)
- Query result caching with invalidation
- Distributed query execution (Spark integration)
- GraphQL API layer
- Real-time streaming query evaluation

---

**v0.1.9 - Performance Verified & SIMD Accelerated**
*Target: 2-3 weeks from v0.1.8*
